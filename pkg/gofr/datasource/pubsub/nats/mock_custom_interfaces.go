// Code generated by MockGen. DO NOT EDIT.
// Source: ./interfaces.go
//
// Generated by this command:
//
//	mockgen -destination=mock_custom_interfaces.go -package=nats -source=./interfaces.go Client,Connection,Subscription,JetStreamContext,Msg
//

// Package nats is a generated GoMock package.
package nats

import (
	context "context"
	reflect "reflect"
	time "time"

	nats "github.com/nats-io/nats.go"
	jetstream "github.com/nats-io/nats.go/jetstream"
	gomock "go.uber.org/mock/gomock"
	pubsub "gofr.dev/pkg/gofr/datasource/pubsub"
)

// MockMsg is a mock of Msg interface.
type MockMsg struct {
	ctrl     *gomock.Controller
	recorder *MockMsgMockRecorder
}

// MockMsgMockRecorder is the mock recorder for MockMsg.
type MockMsgMockRecorder struct {
	mock *MockMsg
}

// NewMockMsg creates a new mock instance.
func NewMockMsg(ctrl *gomock.Controller) *MockMsg {
	mock := &MockMsg{ctrl: ctrl}
	mock.recorder = &MockMsgMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMsg) EXPECT() *MockMsgMockRecorder {
	return m.recorder
}

// Ack mocks base method.
func (m *MockMsg) Ack() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ack")
	ret0, _ := ret[0].(error)
	return ret0
}

// Ack indicates an expected call of Ack.
func (mr *MockMsgMockRecorder) Ack() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ack", reflect.TypeOf((*MockMsg)(nil).Ack))
}

// Data mocks base method.
func (m *MockMsg) Data() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Data")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Data indicates an expected call of Data.
func (mr *MockMsgMockRecorder) Data() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Data", reflect.TypeOf((*MockMsg)(nil).Data))
}

// DoubleAck mocks base method.
func (m *MockMsg) DoubleAck(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoubleAck", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoubleAck indicates an expected call of DoubleAck.
func (mr *MockMsgMockRecorder) DoubleAck(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoubleAck", reflect.TypeOf((*MockMsg)(nil).DoubleAck), arg0)
}

// Headers mocks base method.
func (m *MockMsg) Headers() nats.Header {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Headers")
	ret0, _ := ret[0].(nats.Header)
	return ret0
}

// Headers indicates an expected call of Headers.
func (mr *MockMsgMockRecorder) Headers() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Headers", reflect.TypeOf((*MockMsg)(nil).Headers))
}

// InProgress mocks base method.
func (m *MockMsg) InProgress() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InProgress")
	ret0, _ := ret[0].(error)
	return ret0
}

// InProgress indicates an expected call of InProgress.
func (mr *MockMsgMockRecorder) InProgress() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InProgress", reflect.TypeOf((*MockMsg)(nil).InProgress))
}

// Metadata mocks base method.
func (m *MockMsg) Metadata() (*jetstream.MsgMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metadata")
	ret0, _ := ret[0].(*jetstream.MsgMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Metadata indicates an expected call of Metadata.
func (mr *MockMsgMockRecorder) Metadata() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metadata", reflect.TypeOf((*MockMsg)(nil).Metadata))
}

// Nak mocks base method.
func (m *MockMsg) Nak() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Nak")
	ret0, _ := ret[0].(error)
	return ret0
}

// Nak indicates an expected call of Nak.
func (mr *MockMsgMockRecorder) Nak() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nak", reflect.TypeOf((*MockMsg)(nil).Nak))
}

// NakWithDelay mocks base method.
func (m *MockMsg) NakWithDelay(delay time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NakWithDelay", delay)
	ret0, _ := ret[0].(error)
	return ret0
}

// NakWithDelay indicates an expected call of NakWithDelay.
func (mr *MockMsgMockRecorder) NakWithDelay(delay any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NakWithDelay", reflect.TypeOf((*MockMsg)(nil).NakWithDelay), delay)
}

// Reply mocks base method.
func (m *MockMsg) Reply() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reply")
	ret0, _ := ret[0].(string)
	return ret0
}

// Reply indicates an expected call of Reply.
func (mr *MockMsgMockRecorder) Reply() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reply", reflect.TypeOf((*MockMsg)(nil).Reply))
}

// Subject mocks base method.
func (m *MockMsg) Subject() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subject")
	ret0, _ := ret[0].(string)
	return ret0
}

// Subject indicates an expected call of Subject.
func (mr *MockMsgMockRecorder) Subject() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subject", reflect.TypeOf((*MockMsg)(nil).Subject))
}

// Term mocks base method.
func (m *MockMsg) Term() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Term")
	ret0, _ := ret[0].(error)
	return ret0
}

// Term indicates an expected call of Term.
func (mr *MockMsgMockRecorder) Term() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Term", reflect.TypeOf((*MockMsg)(nil).Term))
}

// TermWithReason mocks base method.
func (m *MockMsg) TermWithReason(reason string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TermWithReason", reason)
	ret0, _ := ret[0].(error)
	return ret0
}

// TermWithReason indicates an expected call of TermWithReason.
func (mr *MockMsgMockRecorder) TermWithReason(reason any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TermWithReason", reflect.TypeOf((*MockMsg)(nil).TermWithReason), reason)
}

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockClient) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockClientMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockClient)(nil).Close))
}

// Publish mocks base method.
func (m *MockClient) Publish(ctx context.Context, stream string, message []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", ctx, stream, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockClientMockRecorder) Publish(ctx, stream, message any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockClient)(nil).Publish), ctx, stream, message)
}

// Subscribe mocks base method.
func (m *MockClient) Subscribe(ctx context.Context, stream string) (*pubsub.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, stream)
	ret0, _ := ret[0].(*pubsub.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockClientMockRecorder) Subscribe(ctx, stream any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockClient)(nil).Subscribe), ctx, stream)
}

// MockSubscription is a mock of Subscription interface.
type MockSubscription struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriptionMockRecorder
}

// MockSubscriptionMockRecorder is the mock recorder for MockSubscription.
type MockSubscriptionMockRecorder struct {
	mock *MockSubscription
}

// NewMockSubscription creates a new mock instance.
func NewMockSubscription(ctrl *gomock.Controller) *MockSubscription {
	mock := &MockSubscription{ctrl: ctrl}
	mock.recorder = &MockSubscriptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubscription) EXPECT() *MockSubscriptionMockRecorder {
	return m.recorder
}

// Drain mocks base method.
func (m *MockSubscription) Drain() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Drain")
	ret0, _ := ret[0].(error)
	return ret0
}

// Drain indicates an expected call of Drain.
func (mr *MockSubscriptionMockRecorder) Drain() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drain", reflect.TypeOf((*MockSubscription)(nil).Drain))
}

// Fetch mocks base method.
func (m *MockSubscription) Fetch(batch int, opts ...nats.PullOpt) ([]*nats.Msg, error) {
	m.ctrl.T.Helper()
	varargs := []any{batch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Fetch", varargs...)
	ret0, _ := ret[0].([]*nats.Msg)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Fetch indicates an expected call of Fetch.
func (mr *MockSubscriptionMockRecorder) Fetch(batch any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{batch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockSubscription)(nil).Fetch), varargs...)
}

// NextMsg mocks base method.
func (m *MockSubscription) NextMsg(timeout time.Duration) (*nats.Msg, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NextMsg", timeout)
	ret0, _ := ret[0].(*nats.Msg)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NextMsg indicates an expected call of NextMsg.
func (mr *MockSubscriptionMockRecorder) NextMsg(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NextMsg", reflect.TypeOf((*MockSubscription)(nil).NextMsg), timeout)
}

// Unsubscribe mocks base method.
func (m *MockSubscription) Unsubscribe() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockSubscriptionMockRecorder) Unsubscribe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockSubscription)(nil).Unsubscribe))
}

// MockConnection is a mock of Connection interface.
type MockConnection struct {
	ctrl     *gomock.Controller
	recorder *MockConnectionMockRecorder
}

// MockConnectionMockRecorder is the mock recorder for MockConnection.
type MockConnectionMockRecorder struct {
	mock *MockConnection
}

// NewMockConnection creates a new mock instance.
func NewMockConnection(ctrl *gomock.Controller) *MockConnection {
	mock := &MockConnection{ctrl: ctrl}
	mock.recorder = &MockConnectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnection) EXPECT() *MockConnectionMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockConnection) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockConnectionMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConnection)(nil).Close))
}

// Drain mocks base method.
func (m *MockConnection) Drain() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Drain")
	ret0, _ := ret[0].(error)
	return ret0
}

// Drain indicates an expected call of Drain.
func (mr *MockConnectionMockRecorder) Drain() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drain", reflect.TypeOf((*MockConnection)(nil).Drain))
}

// JetStream mocks base method.
func (m *MockConnection) JetStream(opts ...nats.JSOpt) (JetStreamContext, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JetStream", varargs...)
	ret0, _ := ret[0].(JetStreamContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// JetStream indicates an expected call of JetStream.
func (mr *MockConnectionMockRecorder) JetStream(opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JetStream", reflect.TypeOf((*MockConnection)(nil).JetStream), opts...)
}

// Status mocks base method.
func (m *MockConnection) Status() nats.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(nats.Status)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockConnectionMockRecorder) Status() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockConnection)(nil).Status))
}

// MockJetStreamContext is a mock of JetStreamContext interface.
type MockJetStreamContext struct {
	ctrl     *gomock.Controller
	recorder *MockJetStreamContextMockRecorder
}

// MockJetStreamContextMockRecorder is the mock recorder for MockJetStreamContext.
type MockJetStreamContextMockRecorder struct {
	mock *MockJetStreamContext
}

// NewMockJetStreamContext creates a new mock instance.
func NewMockJetStreamContext(ctrl *gomock.Controller) *MockJetStreamContext {
	mock := &MockJetStreamContext{ctrl: ctrl}
	mock.recorder = &MockJetStreamContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJetStreamContext) EXPECT() *MockJetStreamContextMockRecorder {
	return m.recorder
}

// AccountInfo mocks base method.
func (m *MockJetStreamContext) AccountInfo(opts ...nats.JSOpt) (*nats.AccountInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AccountInfo", varargs...)
	ret0, _ := ret[0].(*nats.AccountInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AccountInfo indicates an expected call of AccountInfo.
func (mr *MockJetStreamContextMockRecorder) AccountInfo(opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AccountInfo", reflect.TypeOf((*MockJetStreamContext)(nil).AccountInfo), opts...)
}

// AddConsumer mocks base method.
func (m *MockJetStreamContext) AddConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{stream, cfg}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddConsumer", varargs...)
	ret0, _ := ret[0].(*nats.ConsumerInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddConsumer indicates an expected call of AddConsumer.
func (mr *MockJetStreamContextMockRecorder) AddConsumer(stream, cfg any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stream, cfg}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddConsumer", reflect.TypeOf((*MockJetStreamContext)(nil).AddConsumer), varargs...)
}

// AddStream mocks base method.
func (m *MockJetStreamContext) AddStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{cfg}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddStream", varargs...)
	ret0, _ := ret[0].(*nats.StreamInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddStream indicates an expected call of AddStream.
func (mr *MockJetStreamContextMockRecorder) AddStream(cfg any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{cfg}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddStream", reflect.TypeOf((*MockJetStreamContext)(nil).AddStream), varargs...)
}

// ChanSubscribe mocks base method.
func (m *MockJetStreamContext) ChanSubscribe(subj string, ch chan *nats.Msg, opts ...nats.SubOpt) (*nats.Subscription, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, ch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChanSubscribe", varargs...)
	ret0, _ := ret[0].(*nats.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChanSubscribe indicates an expected call of ChanSubscribe.
func (mr *MockJetStreamContextMockRecorder) ChanSubscribe(subj, ch any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, ch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChanSubscribe", reflect.TypeOf((*MockJetStreamContext)(nil).ChanSubscribe), varargs...)
}

// ConsumerInfo mocks base method.
func (m *MockJetStreamContext) ConsumerInfo(stream, name string, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{stream, name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConsumerInfo", varargs...)
	ret0, _ := ret[0].(*nats.ConsumerInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConsumerInfo indicates an expected call of ConsumerInfo.
func (mr *MockJetStreamContextMockRecorder) ConsumerInfo(stream, name any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stream, name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumerInfo", reflect.TypeOf((*MockJetStreamContext)(nil).ConsumerInfo), varargs...)
}

// ConsumersInfo mocks base method.
func (m *MockJetStreamContext) ConsumersInfo(stream string, opts ...nats.JSOpt) <-chan *nats.ConsumerInfo {
	m.ctrl.T.Helper()
	varargs := []any{stream}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConsumersInfo", varargs...)
	ret0, _ := ret[0].(<-chan *nats.ConsumerInfo)
	return ret0
}

// ConsumersInfo indicates an expected call of ConsumersInfo.
func (mr *MockJetStreamContextMockRecorder) ConsumersInfo(stream any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stream}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumersInfo", reflect.TypeOf((*MockJetStreamContext)(nil).ConsumersInfo), varargs...)
}

// DeleteConsumer mocks base method.
func (m *MockJetStreamContext) DeleteConsumer(stream, consumer string, opts ...nats.JSOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{stream, consumer}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteConsumer", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteConsumer indicates an expected call of DeleteConsumer.
func (mr *MockJetStreamContextMockRecorder) DeleteConsumer(stream, consumer any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stream, consumer}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteConsumer", reflect.TypeOf((*MockJetStreamContext)(nil).DeleteConsumer), varargs...)
}

// DeleteMsg mocks base method.
func (m *MockJetStreamContext) DeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{name, seq}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteMsg", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteMsg indicates an expected call of DeleteMsg.
func (mr *MockJetStreamContextMockRecorder) DeleteMsg(name, seq any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name, seq}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMsg", reflect.TypeOf((*MockJetStreamContext)(nil).DeleteMsg), varargs...)
}

// DeleteStream mocks base method.
func (m *MockJetStreamContext) DeleteStream(name string, opts ...nats.JSOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteStream", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteStream indicates an expected call of DeleteStream.
func (mr *MockJetStreamContextMockRecorder) DeleteStream(name any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteStream", reflect.TypeOf((*MockJetStreamContext)(nil).DeleteStream), varargs...)
}

// GetLastMsg mocks base method.
func (m *MockJetStreamContext) GetLastMsg(name, subject string, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	m.ctrl.T.Helper()
	varargs := []any{name, subject}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLastMsg", varargs...)
	ret0, _ := ret[0].(*nats.RawStreamMsg)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLastMsg indicates an expected call of GetLastMsg.
func (mr *MockJetStreamContextMockRecorder) GetLastMsg(name, subject any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name, subject}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLastMsg", reflect.TypeOf((*MockJetStreamContext)(nil).GetLastMsg), varargs...)
}

// GetMsg mocks base method.
func (m *MockJetStreamContext) GetMsg(name string, seq uint64, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	m.ctrl.T.Helper()
	varargs := []any{name, seq}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMsg", varargs...)
	ret0, _ := ret[0].(*nats.RawStreamMsg)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMsg indicates an expected call of GetMsg.
func (mr *MockJetStreamContextMockRecorder) GetMsg(name, seq any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name, seq}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMsg", reflect.TypeOf((*MockJetStreamContext)(nil).GetMsg), varargs...)
}

// Publish mocks base method.
func (m *MockJetStreamContext) Publish(subj string, data []byte, opts ...nats.PubOpt) (*nats.PubAck, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, data}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(*nats.PubAck)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Publish indicates an expected call of Publish.
func (mr *MockJetStreamContextMockRecorder) Publish(subj, data any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, data}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockJetStreamContext)(nil).Publish), varargs...)
}

// PublishAsync mocks base method.
func (m *MockJetStreamContext) PublishAsync(subj string, data []byte, opts ...nats.PubOpt) (nats.PubAckFuture, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, data}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PublishAsync", varargs...)
	ret0, _ := ret[0].(nats.PubAckFuture)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublishAsync indicates an expected call of PublishAsync.
func (mr *MockJetStreamContextMockRecorder) PublishAsync(subj, data any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, data}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishAsync", reflect.TypeOf((*MockJetStreamContext)(nil).PublishAsync), varargs...)
}

// PublishMsg mocks base method.
func (m_2 *MockJetStreamContext) PublishMsg(m *nats.Msg, opts ...nats.PubOpt) (*nats.PubAck, error) {
	m_2.ctrl.T.Helper()
	varargs := []any{m}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m_2.ctrl.Call(m_2, "PublishMsg", varargs...)
	ret0, _ := ret[0].(*nats.PubAck)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublishMsg indicates an expected call of PublishMsg.
func (mr *MockJetStreamContextMockRecorder) PublishMsg(m any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{m}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishMsg", reflect.TypeOf((*MockJetStreamContext)(nil).PublishMsg), varargs...)
}

// PublishMsgAsync mocks base method.
func (m_2 *MockJetStreamContext) PublishMsgAsync(m *nats.Msg, opts ...nats.PubOpt) (nats.PubAckFuture, error) {
	m_2.ctrl.T.Helper()
	varargs := []any{m}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m_2.ctrl.Call(m_2, "PublishMsgAsync", varargs...)
	ret0, _ := ret[0].(nats.PubAckFuture)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublishMsgAsync indicates an expected call of PublishMsgAsync.
func (mr *MockJetStreamContextMockRecorder) PublishMsgAsync(m any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{m}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishMsgAsync", reflect.TypeOf((*MockJetStreamContext)(nil).PublishMsgAsync), varargs...)
}

// PullSubscribe mocks base method.
func (m *MockJetStreamContext) PullSubscribe(subj, durable string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, durable}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PullSubscribe", varargs...)
	ret0, _ := ret[0].(*nats.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PullSubscribe indicates an expected call of PullSubscribe.
func (mr *MockJetStreamContextMockRecorder) PullSubscribe(subj, durable any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, durable}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PullSubscribe", reflect.TypeOf((*MockJetStreamContext)(nil).PullSubscribe), varargs...)
}

// PurgeStream mocks base method.
func (m *MockJetStreamContext) PurgeStream(name string, opts ...nats.JSOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PurgeStream", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PurgeStream indicates an expected call of PurgeStream.
func (mr *MockJetStreamContextMockRecorder) PurgeStream(name any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PurgeStream", reflect.TypeOf((*MockJetStreamContext)(nil).PurgeStream), varargs...)
}

// QueueSubscribe mocks base method.
func (m *MockJetStreamContext) QueueSubscribe(subj, queue string, cb nats.MsgHandler, opts ...nats.SubOpt) (*nats.Subscription, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, queue, cb}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueueSubscribe", varargs...)
	ret0, _ := ret[0].(*nats.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueueSubscribe indicates an expected call of QueueSubscribe.
func (mr *MockJetStreamContextMockRecorder) QueueSubscribe(subj, queue, cb any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, queue, cb}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueSubscribe", reflect.TypeOf((*MockJetStreamContext)(nil).QueueSubscribe), varargs...)
}

// QueueSubscribeSync mocks base method.
func (m *MockJetStreamContext) QueueSubscribeSync(subj, queue string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, queue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueueSubscribeSync", varargs...)
	ret0, _ := ret[0].(*nats.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueueSubscribeSync indicates an expected call of QueueSubscribeSync.
func (mr *MockJetStreamContextMockRecorder) QueueSubscribeSync(subj, queue any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, queue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueSubscribeSync", reflect.TypeOf((*MockJetStreamContext)(nil).QueueSubscribeSync), varargs...)
}

// StreamInfo mocks base method.
func (m *MockJetStreamContext) StreamInfo(stream string, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{stream}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StreamInfo", varargs...)
	ret0, _ := ret[0].(*nats.StreamInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StreamInfo indicates an expected call of StreamInfo.
func (mr *MockJetStreamContextMockRecorder) StreamInfo(stream any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stream}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StreamInfo", reflect.TypeOf((*MockJetStreamContext)(nil).StreamInfo), varargs...)
}

// StreamNames mocks base method.
func (m *MockJetStreamContext) StreamNames(opts ...nats.JSOpt) <-chan string {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StreamNames", varargs...)
	ret0, _ := ret[0].(<-chan string)
	return ret0
}

// StreamNames indicates an expected call of StreamNames.
func (mr *MockJetStreamContextMockRecorder) StreamNames(opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StreamNames", reflect.TypeOf((*MockJetStreamContext)(nil).StreamNames), opts...)
}

// StreamsInfo mocks base method.
func (m *MockJetStreamContext) StreamsInfo(opts ...nats.JSOpt) <-chan *nats.StreamInfo {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StreamsInfo", varargs...)
	ret0, _ := ret[0].(<-chan *nats.StreamInfo)
	return ret0
}

// StreamsInfo indicates an expected call of StreamsInfo.
func (mr *MockJetStreamContextMockRecorder) StreamsInfo(opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StreamsInfo", reflect.TypeOf((*MockJetStreamContext)(nil).StreamsInfo), opts...)
}

// Subscribe mocks base method.
func (m *MockJetStreamContext) Subscribe(subj string, cb nats.MsgHandler, opts ...nats.SubOpt) (*nats.Subscription, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj, cb}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(*nats.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockJetStreamContextMockRecorder) Subscribe(subj, cb any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj, cb}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockJetStreamContext)(nil).Subscribe), varargs...)
}

// SubscribeSync mocks base method.
func (m *MockJetStreamContext) SubscribeSync(subj string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	m.ctrl.T.Helper()
	varargs := []any{subj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeSync", varargs...)
	ret0, _ := ret[0].(*nats.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeSync indicates an expected call of SubscribeSync.
func (mr *MockJetStreamContextMockRecorder) SubscribeSync(subj any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{subj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeSync", reflect.TypeOf((*MockJetStreamContext)(nil).SubscribeSync), varargs...)
}

// UpdateConsumer mocks base method.
func (m *MockJetStreamContext) UpdateConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{stream, cfg}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateConsumer", varargs...)
	ret0, _ := ret[0].(*nats.ConsumerInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateConsumer indicates an expected call of UpdateConsumer.
func (mr *MockJetStreamContextMockRecorder) UpdateConsumer(stream, cfg any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stream, cfg}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateConsumer", reflect.TypeOf((*MockJetStreamContext)(nil).UpdateConsumer), varargs...)
}

// UpdateStream mocks base method.
func (m *MockJetStreamContext) UpdateStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{cfg}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateStream", varargs...)
	ret0, _ := ret[0].(*nats.StreamInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateStream indicates an expected call of UpdateStream.
func (mr *MockJetStreamContextMockRecorder) UpdateStream(cfg any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{cfg}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStream", reflect.TypeOf((*MockJetStreamContext)(nil).UpdateStream), varargs...)
}
